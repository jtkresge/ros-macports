#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
A simple script to take a set of packages in a ROS workspace and conver them
into a set of macports ports with a fully working dependency tree.
"""

import os
import argparse
import shutil
import yaml
from xml.dom import minidom as xml
import re
import hashlib
import subprocess

def readfile(file):
    with open(file) as f:
        return "".join(f.readlines())


def writefile(fname, data):
    with open(fname, "w") as f:
        f.write(data)


def parseargs():
    parser = argparse.ArgumentParser()
    parser.add_argument("--rosdistro",
                        help="the rosdistro being processed",
                        required=True)
    parser.add_argument("--rosinstall",
                        help="the rosinstall file which specifies what ports" \
                             "to generate",
                        required=True)
    parser.add_argument("--system-deps",
                        help="a YAML file mapping ros-named system" \
                             "dependencies to macports port names. This is" \
                             "generated by system_dependency_generator",
                        required=True)
    parser.add_argument("--pkg-instructions",
                        help="a YAML file listing extra code needed to build" \
                             "individual packages. The entries here will be" \
                             "injected into the respective generated package",
                        required=True)
    parser.add_argument("--port-dir",
                        help="the directory for the generated ports. if not " \
                             "specified, defaults to ../ports",
                        default="../ports")
    parser.add_argument("--force-download",
                        help="force redownload, even if cache exists",
                        action="store_true")
    return parser.parse_args()


def download_workspace(rosinstallfile, cachedir):
    if not os.path.exists(cachedir):
        os.mkdir(cachedir)
    rtn = subprocess.call(["./rosports_downloader --rosinstall " + rosinstallfile +
              " --workspace " + cachedir], shell=True)
    if rtn != 0:
        return -1

    return 0


def extract_workspace(cachedir):
    pkgdirs = [pkgdir for pkgdir in os.listdir(cachedir) if
               not pkgdir.startswith(".") and os.path.isdir(
                   cachedir + "/" + pkgdir)]
    for pkgdir in pkgdirs:
        if os.path.exists(cachedir + "/" + pkgdir):
            shutil.rmtree(cachedir + "/" + pkgdir)

    pkgs = [pkg for pkg in os.listdir(cachedir) if
            not pkg.startswith(".") and not os.path.isdir(pkg)]
    for pkg in pkgs:
        print("Extracting {0}".format(pkg))
        os.system("tar -zxvf {0} -C {1}".format(cachedir + "/" +
                                                pkg, cachedir))


def find_download_url(cachedir, pkgname):
    with open(os.path.join(cachedir, pkgname) + "-url") as f:
        return f.readlines()[0]


def create_depedency_list(deps, deps_map, prefix):
    for i in range(len(deps)):
        if deps[i] in deps_map:
            try:
                print("Trying to map sys dep: {0}".format(deps[i]))
                deps[i] = deps_map[deps[i]]["osx"]["macports"]["packages"][0]
                print("Mapped dependency to: {0}".format(deps[i]))
            except IndexError:
                print("Error: needed port mapping not found in system-deps "
                    "file. Please fix yaml mapping.")
        else:
            print ("Adding ros dependency: {0}".format(deps[i]))
            deps[i] = prefix + deps[i]

    return deps


def pull_depedencies_format1(manifest, deps_map, prefix):
    build_deps = [ele.lastChild.nodeValue for ele in
                  manifest.getElementsByTagName("build_depend")]
    depends = create_depedency_list(build_deps, deps_map, prefix)

    buildtool_deps = [ele.lastChild.nodeValue for ele in
                  manifest.getElementsByTagName("buildtool_depend")]
    depends = depends + create_depedency_list(buildtool_deps, deps_map, prefix)

    run_deps = [ele.lastChild.nodeValue for ele in
                manifest.getElementsByTagName("run_depend")]
    depends = depends + create_depedency_list(run_deps, deps_map, prefix)

    test_deps = [ele.lastChild.nodeValue for ele in
                manifest.getElementsByTagName("test_depend")]
    depends = depends + create_depedency_list(test_deps, deps_map, prefix)

    return depends


def pull_depedencies_format2(manifest, deps_map, prefix):
    build_deps = [ele.lastChild.nodeValue for ele in
                  manifest.getElementsByTagName("build_depend")]
    depends = create_depedency_list(build_deps, deps_map, prefix)

    build_export_deps = [ele.lastChild.nodeValue for ele in
                  manifest.getElementsByTagName("build_export_depend")]
    depends = depends + create_depedency_list(build_export_deps, deps_map, prefix)

    buildtool_deps = [ele.lastChild.nodeValue for ele in
                  manifest.getElementsByTagName("buildtool_depend")]
    depends = depends + create_depedency_list(buildtool_deps, deps_map, prefix)

    buildtool_export_deps = [ele.lastChild.nodeValue for ele in
                  manifest.getElementsByTagName("buildtool_export_depend")]
    depends = depends + create_depedency_list(buildtool_export_deps, deps_map, prefix)

    exec_deps = [ele.lastChild.nodeValue for ele in
                  manifest.getElementsByTagName("exec_depend")]
    depends = depends + create_depedency_list(exec_deps, deps_map, prefix)

    run_deps = [ele.lastChild.nodeValue for ele in
                manifest.getElementsByTagName("depend")]
    depends = depends + create_depedency_list(run_deps, deps_map, prefix)

    doc_deps = [ele.lastChild.nodeValue for ele in
                manifest.getElementsByTagName("doc_depend")]
    depends = depends + create_depedency_list(doc_deps, deps_map, prefix)

    test_deps = [ele.lastChild.nodeValue for ele in
                manifest.getElementsByTagName("test_depend")]
    depends = depends + create_depedency_list(test_deps, deps_map, prefix)

    return depends


def process_package(rosdistro, cachedir, deps_map, pkg, portdir, prefix,
                    pkginstructions):
    """
    For the passed in package, generates a port in pordir using the supplied
    (already generated) cachedir, deps_map, and a prefix for package naming.
    """
    manifest = xml.parse(cachedir + "/" + pkg + "/package.xml")
    format = 1
    if manifest.getElementsByTagName("package")[0].hasAttribute("format"):
        format = manifest.getElementsByTagName("package")[0].attributes["format"].value
    pkgname = manifest.getElementsByTagName("name")[0].lastChild.nodeValue
    version = manifest.getElementsByTagName("version")[0].lastChild.nodeValue
    print("==Processing package: {0}==".format(pkgname))
    if format == 2:
        build_deps = pull_depedencies_format2(manifest)
    else:
        build_deps = pull_depedencies_format1(manifest, deps_map, prefix)

    url = find_download_url(cachedir, pkgname)
    # Whats life without a little golf
    url_base = "/".join(url.split("/")[:-1]) + "/"
    url_file = url.split("/")[-1]
    try:
        revision = re.compile("\d+\.\d+\.\d+-(\d+)\.\D*").split(url_file)[1]
    except IndexError:
        revision = "0"
    checksum = hashlib.sha256(open(cachedir+"/"+pkgname+"-"+url_file,'rb').read()).hexdigest()
    # Add prefix
    build_deps_str = " \\\n                    port:".join(build_deps)
    if build_deps_str is not "":
        build_deps_str = "\\\n                    port:" + build_deps_str
    print (pkgname + " build_depends: " + build_deps_str)
    template = readfile("Portfile-template")
    template = template.replace("$$fullname$$", prefix + pkgname)
    template = template.replace("$$extract_dir$$", pkg)
    template = template.replace("$$build_depends$$", build_deps_str)
    template = template.replace("$$url_base$$", url_base)
    template = template.replace("$$url_file$$", url_file)
    template = template.replace("$$version$$", version)
    template = template.replace("$$revision$$", revision)
    template = template.replace("$$checksum$$", "sha256 "+checksum)

    if pkgname in pkginstructions:
        if "build_code" in pkginstructions[pkgname]:
            template = template.replace("$$pkg_specific_build_code$$",
                                        pkginstructions[pkgname]["build_code"])
        else:
            template = template.replace("$$pkg_specific_build_code$$", "")
        if "top_level" in pkginstructions[pkgname]:
            template = template.replace("$$pkg_specific_top_level$$",
                                        pkginstructions[pkgname]["top_level"])
        else:
            template = template.replace("$$pkg_specific_top_level$$", "")
        if "cmake_args" in pkginstructions[pkgname]:
            template = template.replace("$$pkg_specific_cmake_args$$",
                                        pkginstructions[pkgname]["cmake_args"])
        else:
            template = template.replace("$$pkg_specific_cmake_args$$", "")
        if "post_catkin_build" in pkginstructions[pkgname]:
            template = template.replace("$$pkg_specific_post_catkin_build$$",
                                        pkginstructions[pkgname]["post_catkin_build"])
        else:
            template = template.replace("$$pkg_specific_post_catkin_build$$", "")
    else:
        template = template.replace("$$pkg_specific_top_level$$", "")
        template = template.replace("$$pkg_specific_build_code$$", "")
        template = template.replace("$$pkg_specific_cmake_args$$", "")
        template = template.replace("$$pkg_specific_post_catkin_build$$", "")

    if pkgname == "catkin":
        template = template.replace("$$catkin$$",
                                    "${worksrcpath}/bin/catkin_make_isolated")
        template = template.replace("$$non_catkin$$", "")
    else:
        template = template.replace("$$catkin$$",
                                    "${prefix}/bin/catkin_make_isolated")
        template = template.replace("$$non_catkin$$",
                                    "     file delete -force ${destroot}/opt/local/env.sh\n"
                                    "     file delete -force ${destroot}/opt/local/_setup_util.py\n"
                                    "     file delete -force ${destroot}/opt/local/.catkin\n"
                                    "     file delete -force ${destroot}/opt/local/.rosinstall\n"
                                    "     file delete -force ${destroot}/opt/local/setup.bash\n"
                                    "     file delete -force ${destroot}/opt/local/setup.sh\n"
                                    "     file delete -force ${destroot}/opt/local/setup.zsh\n"
                                    "     file delete -force ${destroot}/opt/local/etc/catkin/profile.d/05.catkin_make.bash\n"
                                    "     file delete -force ${destroot}/opt/local/etc/catkin/profile.d/05.catkin_make_isolated.bash\n"
        )
    # Make ports
    if not os.path.exists(portdir):
        os.mkdir(portdir)
    if not os.path.exists(portdir + "/" + prefix + pkgname):
        os.mkdir(portdir + "/" + prefix + pkgname)
    writefile(portdir + "/" + prefix + pkgname + "/Portfile", template)


def generate_ports():
    """
    Processes command line options and accordingly generates portfiles.
    """
    args = parseargs()

    rosdistro = args.rosdistro
    prefix = ""
    if rosdistro == "indigo":
        prefix = "ros-indigo-"
    elif rosdistro == "hydro":
        prefix = "ros-hydro-"
    elif rosdistro == "groovy":
        prefix = "ros-groovy-"
    portdir = args.port_dir
    force_download = args.force_download
    sysdepsfile = args.system_deps
    pkginstructionsfile = args.pkg_instructions
    rosinstallfile = args.rosinstall
    cachedir = "cache"

    if os.path.exists(cachedir) and force_download:
        shutil.rmtree(cachedir)

    if download_workspace(rosinstallfile, cachedir) != 0:
        print("Error: unable to download entire workspace")
        return -1

    extract_workspace(cachedir)

    pkgs = [pkg for pkg in os.listdir(cachedir) if
            not pkg.startswith(".") and os.path.isdir(cachedir + "/" + pkg)]

    deps_map = yaml.load(open(sysdepsfile))
    print deps_map

    pkginstructions = yaml.load(open(pkginstructionsfile))

    for pkg in pkgs:
        process_package(rosdistro, cachedir, deps_map, pkg, portdir, prefix,
                        pkginstructions)


if __name__ == "__main__":
    generate_ports()
